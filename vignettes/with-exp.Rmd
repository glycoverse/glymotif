---
title: "Working with glyexp"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with glyexp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## When Motifs Meet Experiments: A Perfect Partnership ğŸ¤

The real power of `glymotif` shines brightest when it joins forces with other tools in the `glycoverse` ecosystem.
If you're already using `glyread` to import your glycoproteomics results
and `glyexp` to manage your experimental data, you're in for a treat!
`glymotif` provides some incredibly useful functions to perform `experiment` manipulation 
about motifsâ€”think of it as adding a new lens to your analytical microscope. ğŸ”¬

**Important note:** This vignette assumes you're familiar with the `glyexp` package.
If you haven't met it yet, we highly recommend checking out its
[introduction](https://glycoverse.github.io/glyexp/articles/glyexp.html) first.
Trust usâ€”it's worth the detour! ğŸš€

```{r setup}
library(glymotif)
library(glyexp)
library(dplyr)
```

## Meet Our Star Player: Real Glycoproteomics Data ğŸŒŸ

Time to roll up our sleeves and dive into the good stuff! ğŸ’ª
Let's work with a real-world dataset that will showcase what `glymotif` can do when it teams up with actual experimental data.
We will use `real_experiment` from the `glyexp` package, an serum N-glycoproteomics study with 12 samples.
Firstly, let's use `glyclean::auto_clean()` to preprocess the data.

```{r}
library(glyclean)

exp <- auto_clean(real_experiment)
exp
```

Now, let's peek under the hood and see what treasures we're working with! ğŸ‘€

```{r}
get_var_info(exp)
```

```{r}
get_sample_info(exp)
```

What we have here is a beautiful N-glycoproteomics dataset featuring 500 PSMs (Peptide Spectrum Matches) 
across 12 samples â€” a perfect playground for motif analysis! ğŸ®

**Pro tip:** ğŸ’¡ In real-world data analysis, you'll definitely want to use `glyclean` to perform
data preprocessing before diving into any analysis.
Think of it as washing your vegetables before cookingâ€”essential for the best results! ğŸ¥•

## Adding Motif Annotations to an Experiment ğŸ·ï¸

Here's where things get interesting! ğŸ¤”
We know that the variable information tibble contains all the juicy details about each glycoform - 
the proteins, sites, and glycan structures.
But what if we want to sprinkle some motif magic into the mix?
What if we want to add more columns that tell us about the motifs hiding in our glycans?

**The simple approach:** One motif at a time (very intuitive!) ğŸ¯

```{r}
exp |> 
  mutate_var(n_hex = have_motif(glycan_structure, "Hex(a1-")) |>
  get_var_info() |>
  select(variable, protein, glycan_structure, n_hex)
```

**The tempting approach:** Multiple motifs at once (you might be tempted to do this...) ğŸ¤·â€â™€ï¸

```{r, eval=FALSE}
# Don't do this
exp |>
  mutate_var(
    n_hex = have_motif(glycan_structure, "Hex(a1-"),
    n_hexna = have_motif(glycan_structure, "HexNAc(a1-"),
    n_dhex = have_motif(glycan_structure, "dHex(a1-")
  )
```

Hold on there, speed racer! ğŸ›‘
While this approach works, it's not very efficient, and your computer won't thank you for it.
Here's why: those three separate calls to `have_motif()` all perform time-consuming validations and conversions
on the same set of glycan structures.
It's like washing the same dishes three times instead of doing them all at once! ğŸ½ï¸
Plus, there's a lot of repetitive typing.
You have to type `have_motif` and `glycan_structure` three times â€” talk about finger fatigue! ğŸ˜´

**The smart approach:** Use the `add_motifs_lgl()` or `add_motifs_int()` functions instead! âš¡
They might look like simple syntactic sugar, 
but they're actually optimized powerhouses designed specifically for this exact scenario:

```{r}
exp2 <- exp |> 
  add_motifs_lgl(c(motif1 = "Hex(??-", motif2 = "HexNAc(??-", motif3 = "dHex(??-"))
```

VoilÃ ! ğŸ‰ The motif annotations are now seamlessly integrated into your variable information tibble.

```{r}
exp2 |>
  get_var_info() |>
  select(variable, motif1, motif2, motif3)
```

But wait, what can you actually *do* with these shiny new columns? ğŸ¤”
The possibilities are endless, but here's a tantalizing example to get your creative juices flowing:

```{r, eval=FALSE}
# You can perform pathway enrichment on all glycoproteins containing some motif:
exp2 |>
  filter_var(motif1 == TRUE) |>
  gly_enrich_reactome()  # from the `glystats` package
```

## The Art of Motif Quantification in Experiments ğŸ“Š

Want to quantify the motifs in your experiment?
Try the `glydet` package!
It provides the `quantify_motifs()` function to perform relative and absolute motif quantification.