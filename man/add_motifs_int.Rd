% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add-motifs.R
\name{add_motifs_int}
\alias{add_motifs_int}
\alias{add_motifs_lgl}
\alias{add_motifs_int.glyexp_experiment}
\alias{add_motifs_lgl.glyexp_experiment}
\alias{add_motifs_int.data.frame}
\alias{add_motifs_lgl.data.frame}
\title{Add Motif Annotations}
\usage{
add_motifs_int(
  x,
  motifs,
  alignments = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE,
  match_degree = NULL,
  ...
)

add_motifs_lgl(
  x,
  motifs,
  alignments = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE,
  match_degree = NULL,
  ...
)

\method{add_motifs_int}{glyexp_experiment}(
  x,
  motifs,
  alignments = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE,
  match_degree = NULL,
  ...
)

\method{add_motifs_lgl}{glyexp_experiment}(
  x,
  motifs,
  alignments = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE,
  match_degree = NULL,
  ...
)

\method{add_motifs_int}{data.frame}(
  x,
  motifs,
  alignments = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE,
  match_degree = NULL,
  ...
)

\method{add_motifs_lgl}{data.frame}(
  x,
  motifs,
  alignments = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE,
  match_degree = NULL,
  ...
)
}
\arguments{
\item{x}{A \code{\link[glyexp:experiment]{glyexp::experiment()}} object, or a tibble with a structure column.}

\item{motifs}{One of:
\itemize{
\item A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} vector.
\item A glycan structure string vector, supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}}.
\item A character vector of motif names (use \code{\link[=db_motifs]{db_motifs()}} to see all available motifs).
}}

\item{alignments}{A character vector specifying alignment types for each motif.
Can be a single value (applied to all motifs) or a vector of the same length as motifs.}

\item{ignore_linkages}{A logical value. If \code{TRUE}, linkages will be ignored in the comparison.
Default is \code{FALSE}.}

\item{strict_sub}{A logical value. If \code{TRUE} (default), substituents will be matched in strict mode,
which means if the glycan has a substituent in some residue,
the motif must have the same substituent to be matched.}

\item{match_degree}{A logical vector indicating which motif nodes must match the
glycan's in- and out-degree exactly. For \code{have_motif()}, \code{count_motif()}, and
\code{match_motif()}, this must be a logical vector with length 1 or the number of
motif nodes (length 1 is recycled). For \code{have_motifs()}, \code{count_motifs()}, and
\code{match_motifs()}, this must be a list of logical vectors with length equal to
\code{motifs}; each element follows the same length rules. When \code{match_degree} is
provided, \code{alignment} and \code{alignments} are silently ignored.}

\item{...}{Additional arguments passed to the method.}
}
\value{
An \code{\link[glyexp:experiment]{glyexp::experiment()}} object with motif annotations added to the variable information.
}
\description{
This function adds motif annotations to the variable information
of a \code{\link[glyexp:experiment]{glyexp::experiment()}} or a tibble with a structure column.
\code{add_motifs_int()} adds integer annotations (how many motifs are present).
\code{add_motifs_lgl()} adds boolean annotations (whether the motif is present).
}
\section{About Names}{


The naming rule for the new columns follows these priorities:
\enumerate{
\item If \code{motifs} is a named vector (character or \code{glyrepr::glycan_structure()}),
the names are used directly as column names.
\item If \code{motifs} is unnamed and contains known motif names (e.g., "N-Glycan core"),
the motif names are used as column names.
\item If \code{motifs} is unnamed and contains \code{glyrepr::glycan_structure()} objects
or IUPAC-condensed structure strings, the IUPAC-condensed strings are used
as column names.
}

Note: This behavior differs from \code{\link[=have_motifs]{have_motifs()}} and \code{\link[=count_motifs]{count_motifs()}}, which
return matrices with NULL column names for unnamed IUPAC string or structure
motifs. The functions here always provide column names since they are designed
for adding motif annotations to data frames.
}

\section{Why do we need these functions}{


Adding one motif annotation to a \code{\link[glyexp:experiment]{glyexp::experiment()}} is easy:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{exp |>
  mutate_var(has_hex = have_motif(glycan_structure, "Hex"))
}\if{html}{\out{</div>}}

However, adding multiple motifs is not as straightforward.
You can still use \code{mutate_var()} to add multiple motifs like this:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{exp |>
  mutate_var(
    n_hex = count_motif(glycan_structure, "Hex"),
    n_dhex = count_motif(glycan_structure, "dHex"),
    n_hexnac = count_motif(glycan_structure, "HexNAc"),
  )
}\if{html}{\out{</div>}}

This method has two problems:
\enumerate{
\item it has a lot of boilerplate code (a lot of typing)
\item it is not very efficient, as each call to \code{count_motif}
performs validation and conversion on \code{glycan_structure},
which is a time-consuming process.
}

Therefore, we think it would be better to have a function that
adds multiple motif annotations in a single call, in a more intuitive way.
That's why we provide these two functions.

Under the hood, they use a more straightforward approach for \code{\link[glyexp:experiment]{glyexp::experiment()}} objects:
\enumerate{
\item get the motif annotation matrix using \code{count_motifs()} or \code{have_motifs()}
\item convert the matrix to a tibble
\item use \code{dplyr::bind_cols()} to add the tibble to the variable information
}
}

\examples{
library(glyexp)

exp <- real_experiment2

exp |>
  add_motifs_lgl(c(
    lacnac = "Gal(??-?)GlcNAc(??-",
    sia_lacnac = "Neu5Ac(??-?)Gal(??-?)GlcNAc(??-"
  )) |>
  get_var_info()

exp |>
  add_motifs_int(c(
    lacnac = "Gal(??-?)GlcNAc(??-",
    sia_lacnac = "Neu5Ac(??-?)Gal(??-?)GlcNAc(??-"
  )) |>
  get_var_info()

}
\seealso{
\code{\link[=have_motifs]{have_motifs()}}, \code{\link[=count_motifs]{count_motifs()}}, \code{\link[glyexp:experiment]{glyexp::experiment()}}
}
