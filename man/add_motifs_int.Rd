% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add-motifs.R
\name{add_motifs_int}
\alias{add_motifs_int}
\alias{add_motifs_lgl}
\title{Add Motif Annotations to an Experiment}
\usage{
add_motifs_int(exp, motifs, alignments = NULL, ignore_linkages = FALSE)

add_motifs_lgl(exp, motifs, alignments = NULL, ignore_linkages = FALSE)
}
\arguments{
\item{exp}{An \code{\link[glyexp:experiment]{glyexp::experiment()}} object.}

\item{motifs}{A character vector of motif names, glycan structure strings,
or a 'glyrepr_structure' object.}

\item{alignments}{A character vector specifying alignment types for each motif.
Can be a single value (applied to all motifs) or a vector of the same length as motifs.}

\item{ignore_linkages}{A logical value. If \code{TRUE}, linkages will be ignored in the comparison.}
}
\value{
An \code{\link[glyexp:experiment]{glyexp::experiment()}} object with motif annotations added to the variable information.
}
\description{
This function adds motif annotations to the variable information
of a \code{\link[glyexp:experiment]{glyexp::experiment()}}.
\code{add_motifs_int()} adds integer annotations (how many motifs are present).
\code{add_motifs_lgl()} adds boolean annotations (whether the motif is present).
}
\section{About Names}{


The naming rule for the new columns is similar to that of \code{\link[=have_motifs]{have_motifs()}}.
Briefly, you can use named character vector to name the motifs,
and that will be used as the new column names.
The only catchup is that you cannot pass a named \code{glyrepr::glycan_structure()} to \code{motifs}.
This is a fundamental limitation of the \code{vctrs_rcrd} class,
which \code{glyrepr::glycan_structure()} is built on.
}

\section{Why do we need these functions}{


Adding one motif annotation to a \code{\link[glyexp:experiment]{glyexp::experiment()}} is easy:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{exp |>
  mutate_var(has_hex = have_motif(glycan_structure, "Hex"))
}\if{html}{\out{</div>}}

However, adding multiple motifs is not as straightforward.
You can still use \code{mutate_var()} to add multiple motifs like this:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{exp |>
  mutate_var(
    n_hex = count_motif(glycan_structure, "Hex"),
    n_dhex = count_motif(glycan_structure, "dHex"),
    n_hexnac = count_motif(glycan_structure, "HexNAc"),
  )
}\if{html}{\out{</div>}}

This method has two problems:
\enumerate{
\item it has a lot of boilerplate code (a lot of typing)
\item it is not very efficient, as each call to \code{count_motif}
performs validation and conversion on \code{glycan_structure},
which is a time-consuming process.
}

Advanced R users might want to use \code{count_motifs()}
(the plural cousin of \code{count_motif()}) with \verb{!!!}:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{exp |>
  mutate_var(!!!count_motifs(glycan_structure, c("Hex", "dHex", "HexNAc")))
}\if{html}{\out{</div>}}

Sadly, this doesn't work.
Firstly, \code{count_motifs} returns a matrix, not a list.
Secondly, even if you use \code{as.data.frame()} to convert it to a list,
\verb{!!!} triggers early evaluation of \code{glycan_structure} in the calling environment,
before passing it to \code{count_motifs()}.
This will raise an "object not found" error,
and there is no easy way to fix this, at least for now.

Therefore, we think it would be better to have a function that
adds multiple motif annotations in a single call, in a more intuitive way.
That's why we provide these two functions.

Under the hood, they use a more straightforward approach:
\enumerate{
\item get the motif annotation matrix using \code{count_motifs()} or \code{have_motifs()}
\item convert the matrix to a tibble
\item use \code{dplyr::bind_cols()} to add the tibble to the variable information
}
}

\seealso{
\code{\link[=have_motifs]{have_motifs()}}, \code{\link[=count_motifs]{count_motifs()}}, \code{\link[glyexp:experiment]{glyexp::experiment()}}
}
