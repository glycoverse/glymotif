% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/match-motif.R
\name{match_motif}
\alias{match_motif}
\alias{match_motifs}
\title{Match Motif(s) in Glycans}
\usage{
match_motif(
  glycans,
  motif,
  alignment = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE
)

match_motifs(
  glycans,
  motifs,
  alignments = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE
)
}
\arguments{
\item{glycans}{One of:
\itemize{
\item A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} vector.
\item A glycan structure string vector. All formats supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}} are accepted,
including IUPAC-condensed, WURCS, GlycoCT, and others.
}}

\item{motif}{One of:
\itemize{
\item A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} scalar.
\item A glycan structure string, supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}}.
\item A known motif name (use \code{\link[=all_motifs]{all_motifs()}} to see all available motifs).
}}

\item{alignment}{A character string.
Possible values are "substructure", "core", "terminal" and "whole".
If not provided, the value will be decided based on the \code{motif} argument.
If \code{motif} is a motif name, the alignment in the database will be used.
Otherwise, "substructure" will be used.}

\item{ignore_linkages}{A logical value. If \code{TRUE}, linkages will be ignored in the comparison.
Default is \code{FALSE}.}

\item{strict_sub}{A logical value. If \code{TRUE} (default), substituents will be matched in strict mode,
which means if the glycan has a substituent in some residue,
the motif must have the same substituent to be matched.}

\item{motifs}{One of:
\itemize{
\item A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} vector.
\item A glycan structure string vector, supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}}.
\item A character vector of motif names (use \code{\link[=all_motifs]{all_motifs()}} to see all available motifs).
}}

\item{alignments}{A character vector specifying alignment types for each motif.
Can be a single value (applied to all motifs) or a vector of the same length as motifs.}
}
\value{
A nested list of integer vectors.
\itemize{
\item \code{match_motif()}: Two levels of nesting.
The outer list corresponds to glycans, and the inner list corresponds to matches.
Use \code{purrr::pluck(result, glycan_index, match_index)} to access the match information.
For example, \code{purrr::pluck(result, 1, 2)} means the 2nd match in the 1st glycan.
\item \code{match_motifs()}: Three levels of nesting.
The outermost list corresponds to motifs, the middle list corresponds to glycans,
and the innermost list corresponds to matches.
Use \code{purrr::pluck(result, motif_index, glycan_index, match_index)} to access the match information.
For example, \code{purrr::pluck(result, 1, 2, 3)} means the 3rd match in the 2nd glycan for the 1st motif.
}
}
\description{
These functions find all occurrences of the given \code{motif}(s) in the \code{glycans}.
Node-to-node mapping is returned for each match.
This function is NOT useful for most users if you are not interested in the concrete node mapping.
See \code{\link[=have_motif]{have_motif()}} and \code{\link[=count_motif]{count_motif()}} for more information about the matching rules.
\itemize{
\item \code{match_motif()} matches a single motif against multiple glycans
\item \code{match_motifs()} matches multiple motifs against multiple glycans
}

Different from \code{\link[=have_motif]{have_motif()}} and \code{\link[=count_motif]{count_motif()}},
these functions return detailed match information.
More specifically, for each glycan-motif pair,
a integer vector is returned,
indicating the node mapping from the motif to the glycan.
For example, if the vector is \code{c(2, 3, 6)},
it means that the first node in the motif matches the 2nd node in the glycan,
the second node in the motif matches the 3rd node in the glycan,
and the third node in the motif matches the 6th node in the glycan.

Node indices are only meaningful for \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}},
so only \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} is supported for \code{glycans} and \code{motifs}.
}
\section{Vertex and Linkage Indices}{
The indices of vertices and linkages in a glycan correspond directly to their
order in the IUPAC-condensed string, which is printed when you print a
\code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}}.
For example, for the glycan \verb{Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-)},
the vertices are "Man", "Man", "Man", "GlcNAc", "GlcNAc",
and the linkages are "a1-3", "a1-6", "b1-4", "b1-4".

Thus, matching the motif "Man(a1-3)Man(b1-4)" to this glycan yields \code{c(1, 3)}.
This indicates that the first motif vertex (the a1-3 Man) corresponds to
the first vertex in the glycan, and the second motif vertex (the b1-4 Man)
corresponds to the third vertex in the glycan.
}

\examples{
library(glyparse)
library(glyrepr)

(glycan <- n_glycan_core())

# Let's peek under the hood of the nodes in the glycan
glycan_graph <- get_structure_graphs(glycan)
igraph::V(glycan_graph)$mono # 1, 2, 3, 4, 5

# Match a single motif against a single glycan
motif <- parse_iupac_condensed("Man(a1-3)[Man(a1-6)]Man(b1-")
match_motif(glycan, motif)

# Match multiple motifs against a single glycan
motifs <- c(
  "Man(a1-3)[Man(a1-6)]Man(b1-",
  "Man(a1-3)Man(b1-4)GlcNAc(b1-4)GlcNAc(?1-"
)
motifs <- parse_iupac_condensed(motifs)
match_motifs(glycan, motifs)

}
\seealso{
\code{\link[=have_motif]{have_motif()}}, \code{\link[=count_motif]{count_motif()}}
}
