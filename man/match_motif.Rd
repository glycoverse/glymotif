% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/match-motif.R
\name{match_motif}
\alias{match_motif}
\alias{match_motifs}
\title{Match Motif(s) in Glycans}
\usage{
match_motif(glycans, motif, alignment = NULL, ignore_linkages = FALSE)

match_motifs(glycans, motifs, alignments = NULL, ignore_linkages = FALSE)
}
\arguments{
\item{glycans}{A \code{glyrepr_structure} object.}

\item{motif}{A \code{glyrepr_structure} object with length 1.}

\item{alignment}{A character string.
Possible values are "substructure", "core", "terminal" and "whole".
If not provided, the value will be decided based on the \code{motif} argument.
If \code{motif} is a motif name, the alignment in the database will be used.
Otherwise, "substructure" will be used.}

\item{ignore_linkages}{A logical value. If \code{TRUE}, linkages will be ignored in the comparison.}

\item{motifs}{A \code{glyrepr_structure} object.}

\item{alignments}{A character vector specifying alignment types for each motif.
Can be a single value (applied to all motifs) or a vector of the same length as motifs.}
}
\value{
A nested list of integer vectors.
\itemize{
\item \code{match_motif()}: Two levels of nesting.
The outer list corresponds to glycans, and the inner list corresponds to matches.
Use \code{purrr::pluck(result, glycan_index, match_index)} to access the match information.
For example, \code{purrr::pluck(result, 1, 2)} means the 2nd match in the 1st glycan.
\item \code{match_motifs()}: Three levels of nesting.
The outermost list corresponds to motifs, the middle list corresponds to glycans,
and the innermost list corresponds to matches.
Use \code{purrr::pluck(result, motif_index, glycan_index, match_index)} to access the match information.
For example, \code{purrr::pluck(result, 1, 2, 3)} means the 3rd match in the 2nd glycan for the 1st motif.
}
}
\description{
These functions find all occurrences of the given \code{motif}(s) in the \code{glycans}.
Node-to-node mapping is returned for each match.
This function is NOT useful for most users if you are not interested in the concrete node mapping.
See \code{\link[=have_motif]{have_motif()}} and \code{\link[=count_motif]{count_motif()}} for more information about the matching rules.
\itemize{
\item \code{match_motif()} matches a single motif against multiple glycans
\item \code{match_motifs()} matches multiple motifs against multiple glycans
}

Different from \code{\link[=have_motif]{have_motif()}} and \code{\link[=count_motif]{count_motif()}},
these functions return detailed match information.
More specifically, for each glycan-motif pair,
a integer vector is returned,
indicating the node mapping from the motif to the glycan.
For example, if the vector is \code{c(2, 3, 6)},
it means that the first node in the motif matches the 2nd node in the glycan,
the second node in the motif matches the 3rd node in the glycan,
and the third node in the motif matches the 6th node in the glycan.

Node indices are only meaningful for \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}},
so only \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} is supported for \code{glycans} and \code{motifs}.
}
\examples{
library(glyparse)
library(glyrepr)

(glycan <- n_glycan_core())

# Let's peek under the hood of the nodes in the glycan
glycan_graph <- get_structure_graphs(glycan)
igraph::V(glycan_graph)$mono  # 1, 2, 3, 4, 5

# Match a single motif against a single glycan
motif <- parse_iupac_condensed("Man(a1-3)[Man(a1-6)]Man(b1-")
match_motif(glycan, motif)

# Match multiple motifs against a single glycan
motifs <- c(
  "Man(a1-3)[Man(a1-6)]Man(b1-",
  "Man(a1-3)Man(b1-4)GlcNAc(b1-4)GlcNAc(?1-"
)
motifs <- parse_iupac_condensed(motifs)
match_motifs(glycan, motifs)

}
\seealso{
\code{\link[=have_motif]{have_motif()}}, \code{\link[=count_motif]{count_motif()}}
}
