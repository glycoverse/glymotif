% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/count-motif.R
\name{count_motif}
\alias{count_motif}
\alias{count_motifs}
\title{Count How Many Times Glycans have the Given Motif(s)}
\usage{
count_motif(glycans, motif, alignment = NULL, ignore_linkages = FALSE)

count_motifs(glycans, motifs, alignments = NULL, ignore_linkages = FALSE)
}
\arguments{
\item{glycans}{A 'glyrepr_structure' object, or a glycan structure string vector.}

\item{motif}{A 'glyrepr_structure' object, a glycan structure string,
or a known motif name (use \code{\link[=available_motifs]{available_motifs()}} to see all available motifs).}

\item{alignment}{A character string.
Possible values are "substructure", "core", "terminal" and "whole".
If not provided, the value will be decided based on the \code{motif} argument.
If \code{motif} is a motif name, the alignment in the database will be used.
Otherwise, "substructure" will be used.}

\item{ignore_linkages}{A logical value. If \code{TRUE}, linkages will be ignored in the comparison.}

\item{motifs}{A character vector of motif names, glycan structure strings,
or a 'glyrepr_structure' object.}

\item{alignments}{A character vector specifying alignment types for each motif.
Can be a single value (applied to all motifs) or a vector of the same length as motifs.}
}
\value{
\itemize{
\item \code{count_motif()}: An integer vector indicating how many times each \code{glycan} has the \code{motif}.
\item \code{count_motifs()}: An integer matrix where rows correspond to glycans and columns correspond to motifs.
Row names contain glycan identifiers and column names contain motif identifiers.
}
}
\description{
These functions are closely related to \code{\link[=have_motif]{have_motif()}}.
However, instead of returning logical values, they return the number of times
the \code{glycans} have the \code{motif}(s).
\itemize{
\item \code{count_motif()} counts a single motif in multiple glycans
\item \code{count_motifs()} counts multiple motifs in multiple glycans
}
}
\details{
This function actually perform v2f algorithm to get all possible matches
between \code{glycans} and \code{motif}.
However, the result is not necessarily the number of matches.

Think about the following example:
\itemize{
\item glycan: \verb{Gal(b1-?)[Gal(b1-?)]GlcNAc(b1-4)GlcNAc(b1-}
\item motif: \verb{Gal(b1-?)[Gal(b1-?)]GlcNAc(b1-}
}

To draw the glycan out:

\if{html}{\out{<div class="sourceCode">}}\preformatted{Gal 1
   \\ b1-? b1-4
    GlcNAc -- GlcNAc b1-
   / b1-?
Gal 2
}\if{html}{\out{</div>}}

To draw the motif out:

\if{html}{\out{<div class="sourceCode">}}\preformatted{Gal 1
   \\ b1-?
    GlcNAc b1-
   / b1-?
Gal 2
}\if{html}{\out{</div>}}

To differentiate the galactoses, we number them as "Gal 1" and "Gal 2"
in both the glycan and the motif.
The v2f subisomorphic algorithm will return two matches:
\itemize{
\item Gal 1 in the glycan matches Gal 1 in the motif, and Gal 2 matches Gal 2.
\item Gal 1 in the glycan matches Gal 2 in the motif, and Gal 2 matches Gal 1.
}

However, from a biological perspective, the two matches are the same.
This function will take care of this, and return the "unique" number of matches.

For other details about the handling of monosaccharide, linkages, alignment,
substituents, and implementation, see \code{\link[=have_motif]{have_motif()}}.
}
\section{About Names}{
\code{have_motif()} and \code{count_motif()} return a vector with no names.
It is easy to trace the names back to the original glycans.

\code{have_motifs()} and \code{count_motifs()} return a matrix with both row and column names.
The row names are the glycan names, and the column names are the motif names.
The names are decided according to the following rules:
\enumerate{
\item If \code{glycans} or \code{motifs} is a \code{glyrepr::glycan_structure()} object,
the names are the IUPAC-condensed structure strings.
(Sadly due to the constrains of the \code{vctrs} package \code{glyrepr::glycan_structure()} is built on,
a \code{glyrepr::glycan_structure()} vector cannot have names.)
\item If \code{glycans} or \code{motifs} is a character vector, either IUPAC-condensed structure strings or
motif names, it will use the names of the character vector if exists,
otherwise use the character vector itself as the names.
}
}

\section{Input Formats}{
Besides \code{glyrepr::glycan_structure()}s,
\code{glycans}, \code{motif} and \code{motifs} can be glycan structure text nomenclatures of any supported format,
including IUPAC-condensed, IUPAC-short, IUPAC-extended, GlycoCT, WURCS, pGlyco-style, and StrucGP-style.
Under the hood, the function uses \code{glyparse::auto_parse()} to parse the text strings.
}

\examples{
library(glyparse)

count_motif("Gal(b1-3)Gal(b1-3)GalNAc(b1-", "Gal(b1-")
count_motif(
  "Man(b1-?)[Man(b1-?)]GalNAc(b1-4)GlcNAc(b1-",
  "Man(b1-?)[Man(b1-?)]GalNAc(b1-"
)
count_motif("Gal(b1-3)Gal(b1-", "Man(b1-")

# Vectorized usage with single motif
count_motif(c("Gal(b1-3)Gal(b1-3)GalNAc(b1-", "Gal(b1-3)GalNAc(b1-"), "Gal(b1-")

# Multiple motifs with count_motifs()
glycan1 <- parse_iupac_condensed("Gal(b1-3)Gal(b1-3)GalNAc(b1-")
glycan2 <- parse_iupac_condensed("Man(b1-?)[Man(b1-?)]GalNAc(b1-4)GlcNAc(b1-")
glycans <- c(glycan1, glycan2)

motifs <- c("Gal(b1-3)GalNAc(b1-", "Gal(b1-", "Man(b1-")
result <- count_motifs(glycans, motifs)
print(result)

# Monosaccharide type matching examples
# Concrete glycan vs generic motif: matches (glycan converted to generic)
count_motif("Man(?1-", "Hex(?1-")  # Returns 1

# Generic glycan vs concrete motif: doesn't match
count_motif("Hex(?1-", "Man(?1-")  # Returns 0

# Matrix example showing type matching rules
count_motifs(glycans = c("Hex(?1-", "Man(?1-"), motifs = c("Hex(?1-", "Man(?1-"))

}
\seealso{
\code{\link[=have_motif]{have_motif()}}, \code{\link[=have_motifs]{have_motifs()}}
}
