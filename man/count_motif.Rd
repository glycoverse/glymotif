% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/count-motif.R
\name{count_motif}
\alias{count_motif}
\alias{count_motifs}
\title{Count How Many Times Glycans have the Given Motif(s)}
\usage{
count_motif(
  glycans,
  motif,
  alignment = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE,
  match_degree = NULL
)

count_motifs(
  glycans,
  motifs,
  alignments = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE,
  match_degree = NULL
)
}
\arguments{
\item{glycans}{One of:
\itemize{
\item A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} vector.
\item A glycan structure string vector. All formats supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}} are accepted,
including IUPAC-condensed, WURCS, GlycoCT, and others.
}}

\item{motif}{One of:
\itemize{
\item A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} scalar.
\item A glycan structure string, supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}}.
\item A known motif name (use \code{\link[=all_motifs]{all_motifs()}} to see all available motifs).
}}

\item{alignment}{A character string.
Possible values are "substructure", "core", "terminal", and "whole".
If not provided, the value will be decided based on the \code{motif} argument.
If \code{motif} is a motif name, the alignment in the database will be used.
Otherwise, "substructure" will be used.}

\item{ignore_linkages}{A logical value. If \code{TRUE}, linkages will be ignored in the comparison.
Default is \code{FALSE}.}

\item{strict_sub}{A logical value. If \code{TRUE} (default), substituents will be matched in strict mode,
which means if the glycan has a substituent in some residue,
the motif must have the same substituent to be matched.}

\item{match_degree}{A logical vector indicating which motif nodes must match the
glycan's in- and out-degree exactly. For \code{have_motif()}, \code{count_motif()}, and
\code{match_motif()}, this must be a logical vector with length 1 or the number of
motif nodes (length 1 is recycled). For \code{have_motifs()}, \code{count_motifs()}, and
\code{match_motifs()}, this must be a list of logical vectors with length equal to
\code{motifs}; each element follows the same length rules. When \code{match_degree} is
provided, \code{alignment} and \code{alignments} are silently ignored.}

\item{motifs}{One of:
\itemize{
\item A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} vector.
\item A glycan structure string vector, supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}}.
\item A character vector of motif names (use \code{\link[=all_motifs]{all_motifs()}} to see all available motifs).
}}

\item{alignments}{A character vector specifying alignment types for each motif.
Can be a single value (applied to all motifs) or a vector of the same length as motifs.}
}
\value{
\itemize{
\item \code{count_motif()}: An integer vector indicating how many times each \code{glycan} has the \code{motif}.
\item \code{count_motifs()}: An integer matrix where rows correspond to glycans and columns correspond to motifs.
Row names contain glycan identifiers and column names contain motif identifiers.
}
}
\description{
These functions are closely related to \code{\link[=have_motif]{have_motif()}}.
However, instead of returning logical values, they return the number of times
the \code{glycans} have the \code{motif}(s).
\itemize{
\item \code{count_motif()} counts a single motif in multiple glycans
\item \code{count_motifs()} counts multiple motifs in multiple glycans
}
}
\details{
This function actually perform v2f algorithm to get all possible matches
between \code{glycans} and \code{motif}.
However, the result is not necessarily the number of matches.

Think about the following example:
\itemize{
\item glycan: \verb{Gal(b1-?)[Gal(b1-?)]GlcNAc(b1-4)GlcNAc(b1-}
\item motif: \verb{Gal(b1-?)[Gal(b1-?)]GlcNAc(b1-}
}

To draw the glycan out:

\if{html}{\out{<div class="sourceCode">}}\preformatted{Gal 1
   \\ b1-? b1-4
    GlcNAc -- GlcNAc b1-
   / b1-?
Gal 2
}\if{html}{\out{</div>}}

To draw the motif out:

\if{html}{\out{<div class="sourceCode">}}\preformatted{Gal 1
   \\ b1-?
    GlcNAc b1-
   / b1-?
Gal 2
}\if{html}{\out{</div>}}

To differentiate the galactoses, we number them as "Gal 1" and "Gal 2"
in both the glycan and the motif.
The v2f subisomorphic algorithm will return two matches:
\itemize{
\item Gal 1 in the glycan matches Gal 1 in the motif, and Gal 2 matches Gal 2.
\item Gal 1 in the glycan matches Gal 2 in the motif, and Gal 2 matches Gal 1.
}

However, from a biological perspective, the two matches are the same.
This function will take care of this, and return the "unique" number of matches.

For other details about the handling of monosaccharide, linkages, alignment,
substituents, and implementation, see \code{\link[=have_motif]{have_motif()}}.
}
\section{About Names}{
\code{have_motif()} and \code{count_motif()} return a vector with no names.
It is easy to trace the names back to the original glycans.

\code{have_motifs()} and \code{count_motifs()} return a matrix with both row and column names.
The row names are the glycan names, and the column names are the motif names.
The names are decided according to the following rules:
\enumerate{
\item If \code{glycans} or \code{motifs} is a \code{glyrepr::glycan_structure()} object,
the names are the IUPAC-condensed structure strings.
(Sadly due to the constrains of the \code{vctrs} package \code{glyrepr::glycan_structure()} is built on,
a \code{glyrepr::glycan_structure()} vector cannot have names.)
\item If \code{glycans} or \code{motifs} is a character vector, either IUPAC-condensed structure strings or
motif names, it will use the names of the character vector if exists,
otherwise use the character vector itself as the names.
}
}

\examples{
library(glyparse)

count_motif("Gal(b1-3)Gal(b1-3)GalNAc(b1-", "Gal(b1-")
count_motif(
  "Man(b1-?)[Man(b1-?)]GalNAc(b1-4)GlcNAc(b1-",
  "Man(b1-?)[Man(b1-?)]GalNAc(b1-"
)
count_motif("Gal(b1-3)Gal(b1-", "Man(b1-")

# Vectorized usage with single motif
count_motif(c("Gal(b1-3)Gal(b1-3)GalNAc(b1-", "Gal(b1-3)GalNAc(b1-"), "Gal(b1-")

# Multiple motifs with count_motifs()
glycan1 <- parse_iupac_condensed("Gal(b1-3)Gal(b1-3)GalNAc(b1-")
glycan2 <- parse_iupac_condensed("Man(b1-?)[Man(b1-?)]GalNAc(b1-4)GlcNAc(b1-")
glycans <- c(glycan1, glycan2)

motifs <- c("Gal(b1-3)GalNAc(b1-", "Gal(b1-", "Man(b1-")
result <- count_motifs(glycans, motifs)
print(result)

# Monosaccharide type matching examples
# Concrete glycan vs generic motif: matches (glycan converted to generic)
count_motif("Man(?1-", "Hex(?1-") # Returns 1

# Generic glycan vs concrete motif: doesn't match
count_motif("Hex(?1-", "Man(?1-") # Returns 0

}
\seealso{
\code{\link[=have_motif]{have_motif()}}, \code{\link[=have_motifs]{have_motifs()}}
}
