% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/count-motif.R, R/vectorized.R
\name{count_motif}
\alias{count_motif}
\alias{count_motifs}
\title{Count How Many Times Glycans have the Given Motif(s)}
\usage{
count_motif(glycans, motif, alignment = NULL, ignore_linkages = FALSE)

count_motifs(glycans, motifs, alignments = NULL, ignore_linkages = FALSE)
}
\arguments{
\item{glycans}{A 'glyrepr_structure' object, or an IUPAC-condensed structure string vector.}

\item{motif}{A 'glyrepr_structure' object, an IUPAC-condensed structure string,
or a known motif name (use \code{\link[=available_motifs]{available_motifs()}} to see all available motifs).}

\item{alignment}{A character string.
Possible values are "substructure", "core", "terminal" and "whole".
If not provided, the value will be decided based on the \code{motif} argument.
If \code{motif} is a motif name, the alignment in the database will be used.
Otherwise, "substructure" will be used.}

\item{ignore_linkages}{A logical value. If \code{TRUE}, linkages will be ignored in the comparison.}

\item{motifs}{A character vector of motif names, IUPAC-condensed structure strings,
or a 'glyrepr_structure' object.}

\item{alignments}{A character vector specifying alignment types for each motif.
Can be a single value (applied to all motifs) or a vector of the same length as motifs.}
}
\value{
\itemize{
\item \code{count_motif()}: An integer vector indicating how many times each \code{glycan} has the \code{motif}.
\item \code{count_motifs()}: An integer matrix where rows correspond to glycans and columns correspond to motifs.
Row names contain glycan identifiers and column names contain motif identifiers.
}
}
\description{
These functions are closely related to \code{\link[=have_motif]{have_motif()}}.
However, instead of returning logical values, they return the number of times
the \code{glycans} have the \code{motif}(s).
\itemize{
\item \code{count_motif()} counts a single motif in multiple glycans
\item \code{count_motifs()} counts multiple motifs in multiple glycans
}
}
\details{
This function actually perform v2f algorithm to get all possible matches
between \code{glycans} and \code{motif}.
However, the result is not necessarily the number of matches.

Think about the following example:
\itemize{
\item glycan: \verb{Gal(b1-?)[Gal(b1-?)]GlcNAc(b1-4)GlcNAc}
\item motif: \verb{Gal(b1-?)[Gal(b1-?)]GlcNAc(b1-}
}

To draw the glycan out:

\if{html}{\out{<div class="sourceCode">}}\preformatted{Gal 1
   \\ b1-? b1-4
    GlcNAc -- GlcNAc
   / b1-?
Gal 2
}\if{html}{\out{</div>}}

To draw the motif out:

\if{html}{\out{<div class="sourceCode">}}\preformatted{Gal 1
   \\ b1-?
    GlcNAc b1-
   / b1-?
Gal 2
}\if{html}{\out{</div>}}

To differentiate the galactoses, we number them as "Gal 1" and "Gal 2"
in both the glycan and the motif.
The v2f subisomorphic algorithm will return two matches:
\itemize{
\item Gal 1 in the glycan matches Gal 1 in the motif, and Gal 2 matches Gal 2.
\item Gal 1 in the glycan matches Gal 2 in the motif, and Gal 2 matches Gal 1.
}

However, from a biological perspective, the two matches are the same.
This function will take care of this, and return the "unique" number of matches.

For other details about the handling of monosaccharide, linkages, alignment,
substituents, and implementation, see \code{\link[=have_motif]{have_motif()}}.
}
\examples{
library(glyparse)

count_motif("Gal(b1-3)Gal(b1-3)GalNAc", "Gal(b1-")
count_motif(
  "Man(b1-?)[Man(b1-?)]GalNAc(b1-4)GlcNAc",
  "Man(b1-?)[Man(b1-?)]GalNAc"
)
count_motif("Gal(b1-3)Gal", "Man")

# Vectorized usage with single motif
count_motif(c("Gal(b1-3)Gal(b1-3)GalNAc", "Gal(b1-3)GalNAc"), "Gal(b1-")

# Multiple motifs with count_motifs()
glycan1 <- parse_iupac_condensed("Gal(b1-3)Gal(b1-3)GalNAc")
glycan2 <- parse_iupac_condensed("Man(b1-?)[Man(b1-?)]GalNAc(b1-4)GlcNAc")
glycans <- c(glycan1, glycan2)

motifs <- c("Gal(b1-3)GalNAc", "Gal(b1-", "Man(b1-")
result <- count_motifs(glycans, motifs)
print(result)

# Monosaccharide type matching examples
# Concrete glycan vs generic motif: matches (glycan converted to generic)
count_motif("Man", "Hex")  # Returns 1

# Generic glycan vs concrete motif: doesn't match
count_motif("Hex", "Man")  # Returns 0

# Matrix example showing type matching rules
count_motifs(glycans = c("Hex", "Man"), motifs = c("Hex", "Man"))

}
\seealso{
\code{\link[=have_motif]{have_motif()}}, \code{\link[=have_motifs]{have_motifs()}}
}
