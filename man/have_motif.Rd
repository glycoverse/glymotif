% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/have-motif.R
\name{have_motif}
\alias{have_motif}
\alias{have_motifs}
\title{Check if the Glycans have the Given Motif(s)}
\usage{
have_motif(
  glycans,
  motif,
  alignment = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE,
  match_degree = NULL
)

have_motifs(
  glycans,
  motifs,
  alignments = NULL,
  ignore_linkages = FALSE,
  strict_sub = TRUE,
  match_degree = NULL
)
}
\arguments{
\item{glycans}{One of:
\itemize{
\item A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} vector.
\item A glycan structure string vector. All formats supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}} are accepted,
including IUPAC-condensed, WURCS, GlycoCT, and others.
}}

\item{motif}{One of:
\itemize{
\item A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} scalar.
\item A glycan structure string, supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}}.
\item A known motif name (use \code{\link[=all_motifs]{all_motifs()}} to see all available motifs).
}}

\item{alignment}{A character string.
Possible values are "substructure", "core", "terminal", and "whole".
If not provided, the value will be decided based on the \code{motif} argument.
If \code{motif} is a motif name, the alignment in the database will be used.
Otherwise, "substructure" will be used.}

\item{ignore_linkages}{A logical value. If \code{TRUE}, linkages will be ignored in the comparison.
Default is \code{FALSE}.}

\item{strict_sub}{A logical value. If \code{TRUE} (default), substituents will be matched in strict mode,
which means if the glycan has a substituent in some residue,
the motif must have the same substituent to be matched.}

\item{match_degree}{A logical vector indicating which motif nodes must match the
glycan's in- and out-degree exactly. For \code{have_motif()}, \code{count_motif()}, and
\code{match_motif()}, this must be a logical vector with length 1 or the number of
motif nodes (length 1 is recycled). For \code{have_motifs()}, \code{count_motifs()}, and
\code{match_motifs()}, this must be a list of logical vectors with length equal to
\code{motifs}; each element follows the same length rules. When \code{match_degree} is
provided, \code{alignment} and \code{alignments} are silently ignored.}

\item{motifs}{One of:
\itemize{
\item A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} vector.
\item A glycan structure string vector, supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}}.
\item A character vector of motif names (use \code{\link[=all_motifs]{all_motifs()}} to see all available motifs).
}}

\item{alignments}{A character vector specifying alignment types for each motif.
Can be a single value (applied to all motifs) or a vector of the same length as motifs.}
}
\value{
\itemize{
\item \code{have_motif()}: A logical vector indicating if each \code{glycan} has the \code{motif}.
\item \code{have_motifs()}: A logical matrix where rows correspond to glycans and columns correspond to motifs.
Row names contain glycan identifiers and column names contain motif identifiers.
}
}
\description{
These functions check if the given \code{glycan}s have the given \code{motif}(s).
\itemize{
\item \code{have_motif()} checks a single motif against multiple glycans
\item \code{have_motifs()} checks multiple motifs against multiple glycans
}

Technically speaking, they perform subgraph isomorphism tests to
determine if the \code{motif}(s) are subgraphs of the \code{glycan}s.
Monosaccharides, linkages, and substituents are all considered.
}
\section{About Names}{
\code{have_motif()} and \code{count_motif()} return a vector with no names.
It is easy to trace the names back to the original glycans.

\code{have_motifs()} and \code{count_motifs()} return a matrix with both row and column names.
The row names are the glycan names, and the column names are the motif names.
The names are decided according to the following rules:
\enumerate{
\item If \code{glycans} or \code{motifs} is a \code{glyrepr::glycan_structure()} object,
the names are the IUPAC-condensed structure strings.
(Sadly due to the constrains of the \code{vctrs} package \code{glyrepr::glycan_structure()} is built on,
a \code{glyrepr::glycan_structure()} vector cannot have names.)
\item If \code{glycans} or \code{motifs} is a character vector, either IUPAC-condensed structure strings or
motif names, it will use the names of the character vector if exists,
otherwise use the character vector itself as the names.
}
}

\section{Monosaccharide type}{
As of glyrepr 0.9.0.9000, all elements in a \code{glycans} or \code{motifs} vector
must have the same monosaccharide type ("concrete" or "generic").
This invariant is enforced when creating or combining \code{glyrepr_structure} objects.
The matching rules are:
\itemize{
\item When the motif is "generic", glycans are converted to "generic" type for comparison,
allowing both concrete and generic glycans to match generic motifs.
\item When the motif is "concrete", glycans are used as-is, so only concrete glycans
with matching monosaccharide names will match, while generic glycans will not match.
}

Examples:
\itemize{
\item \code{Man} (concrete glycan) vs \code{Hex} (generic motif) → TRUE (Man converted to Hex for comparison)
\item \code{Hex} (generic glycan) vs \code{Man} (concrete motif) → FALSE (names don't match)
\item \code{Man} (concrete glycan) vs \code{Man} (concrete motif) → TRUE (exact match)
\item \code{Hex} (generic glycan) vs \code{Hex} (generic motif) → TRUE (exact match)
}
}

\section{Linkages}{
Obscure linkages (e.g. "??-?") are allowed in the \code{motif} graph
(see \code{\link[glyrepr:possible_linkages]{glyrepr::possible_linkages()}}).
"?" in a motif graph means "anything could be OK",
so it will match any linkage in the \code{glycan} graph.
However, "?" in a \code{glycan} graph will only match "?" in the \code{motif} graph.
You can set \code{ignore_linkages = TRUE} to ignore linkages in the comparison.

Some examples:
\itemize{
\item "b1-?" in motif will match "b1-4" in glycan.
\item "b1-?" in motif will match "b1-?" in glycan.
\item "b1-4" in motif will NOT match "b1-?" in glycan.
\item "a1-?" in motif will NOT match "b1-4" in glycan.
\item "a1-?" in motif will NOT match "a?-4" in glycan.
}

Both motifs and glycans can have a "half-linkage" at the reducing end,
e.g. "GlcNAc(b1-".
The half linkage in the motif will be matched to any linkage in the glycan,
or the half linkage of the glycan.
e.g. Glycan "GlcNAc(b1-4)Gal(a1-" will have both "GlcNAc(b1-" and "Gal(a1-" motifs.
}

\section{Alignment}{
According to the \href{https://glycomotif.glyomics.org}{GlycoMotif} database,
a motif can be classified into four alignment types:
\itemize{
\item "substructure": The motif can be anywhere in the glycan. This is the default.
See \href{https://glycomotif.glyomics.org/glycomotif/Substructure_Alignment}{substructure}
for details.
\item "core": The motif must align with at least one connected substructure
(subtree) at the reducing end of the glycan.
See \href{https://glycomotif.glyomics.org/glycomotif/Glycan_Core_Alignment}{glycan core}
for details.
\item "terminal": The motif must align with at least one connected substructure
(subtree) at the nonreducing end of the glycan.
See \href{https://glycomotif.glyomics.org/glycomotif/Nonreducing-End_Alignment}{nonreducing end}
for details.
\item "whole": The motif must align with the entire glycan.
See \href{https://glycomotif.glyomics.org/glycomotif/Whole-Glycan_Alignment}{whole-glycan}
for details.
}

When using known motifs in the GlycoMotif GlyGen Collection,
the best practice is to not provide the \code{alignment} argument,
and let the function decide the alignment based on the motif name.
However, it is still possible to override the default alignments.
In this case, the user-provided alignments will be used,
but a warning will be issued.
When \code{match_degree} is provided, \code{alignment} and \code{alignments} are ignored
without warning.
}

\section{Degree matching}{
\code{match_degree} is used to require exact degree matching for specific motif nodes.
For each node marked \code{TRUE}, the matched glycan node must have the same in-degree
and out-degree as the motif node. Nodes marked \code{FALSE} do not enforce degree
equality. This is useful to prevent matches where the motif node is embedded in
a more highly branched glycan region (extra outgoing edges) or has extra incoming
connections compared to the motif.
}

\section{Substituents}{
Substituents (e.g. "Ac", "SO3") are matched in strict mode.
Both single and multiple substituents are supported:
\itemize{
\item Single substituents: "Neu5Ac-9Ac" will only match "Neu5Ac-9Ac" but not "Neu5Ac"
\item Multiple substituents: "Glc3Me6S" (has both 3Me and 6S) will only match motifs
that contain both substituents, e.g., "Glc3Me6S", "Glc?Me6S", "Glc3Me?S"
\item "Glc3Me6S" will NOT match "Glc3Me" (missing 6S) or "Glc" (missing both)
}

For multiple substituents, they are internally stored as comma-separated values
(e.g. "3Me,6S") and matched individually. Each substituent in the motif must
have a corresponding match in the glycan, and vice versa.

Obscure linkages in motif substituents will match any linkage in glycan substituents:
\itemize{
\item Motif "Neu5Ac?Ac" will match "Neu5Ac9Ac" in the glycan
\item Motif "Glc?Me6S" will match "Glc3Me6S" in the glycan (? matches 3)
\item Motif "Glc3Me?S" will match "Glc3Me6S" in the glycan (? matches 6)
}

This default behavior is reasonable for most cases,
because monosaccharides with different substituents should be regarded as different.
However, you can change this behavior by setting \code{strict_sub = FALSE}.
In this case, the substituent is optional in the motif,
so the glycan "Neu5Ac9Ac" can match the motif "Neu5Ac".
}

\section{Implementation}{
Under the hood, the function uses \code{\link[igraph:subgraph_isomorphisms]{igraph::graph.get.subisomorphisms.vf2()}}
to get all possible subgraph isomorphisms between \code{glycan} and \code{motif}.
\code{color} vertex attributes are added to the graphs to distinguish monosaccharides.
For all possible matches, the function checks the following:
\itemize{
\item Alignment: using \code{alignment_check()}
\item Substituents: using \code{substituent_check()}
\item Degree: using \code{degree_check()} (only when \code{match_degree} is provided)
\item Linkages: using \code{linkage_check()}
\item Anomer: using \code{anomer_check()}
The function returns \code{TRUE} if any of the matches pass all checks.
}
}

\examples{
library(glyparse)
library(glyrepr)

(glycan <- o_glycan_core_2(mono_type = "concrete"))

# The glycan has the motif "Gal(b1-3)GalNAc(b1-"
have_motif(glycan, "Gal(b1-3)GalNAc(b1-")

# But not "Gal(b1-4)GalNAc(b1-" (wrong linkage)
have_motif(glycan, "Gal(b1-4)GalNAc(b1-")

# Set `ignore_linkages` to `TRUE` to ignore linkages
have_motif(glycan, "Gal(b1-4)GalNAc(b1-", ignore_linkages = TRUE)

# Different monosaccharide types are allowed
have_motif(glycan, "Hex(b1-3)HexNAc(?1-")

# Obscure linkages in the `motif` graph are allowed
have_motif(glycan, "Gal(b1-?)GalNAc(?1-")

# However, obscure linkages in `glycan` will only match "?" in the `motif` graph
glycan_2 <- parse_iupac_condensed("Gal(b1-?)[GlcNAc(b1-6)]GalNAc(?1-")
have_motif(glycan_2, "Gal(b1-3)GalNAc(?1-")
have_motif(glycan_2, "Gal(b1-?)GalNAc(?1-")

# The anomer of the motif will be matched to linkages in the glycan
have_motif(glycan_2, "GlcNAc(b1-")

# Alignment types
# The default type is "substructure", which means the motif can be anywhere in the glycan.
# Other options include "core", "terminal" and "whole".
glycan_3 <- parse_iupac_condensed("Gal(a1-3)Gal(a1-4)Gal(a1-6)Gal(a1-")
motifs <- c(
  "Gal(a1-3)Gal(a1-4)Gal(a1-6)Gal(a1-",
  "Gal(a1-3)Gal(a1-4)Gal(a1-",
  "Gal(a1-4)Gal(a1-6)Gal(a1-",
  "Gal(a1-4)Gal(a1-"
)

purrr::map_lgl(motifs, ~ have_motif(glycan_3, .x, alignment = "whole"))
purrr::map_lgl(motifs, ~ have_motif(glycan_3, .x, alignment = "core"))
purrr::map_lgl(motifs, ~ have_motif(glycan_3, .x, alignment = "terminal"))
purrr::map_lgl(motifs, ~ have_motif(glycan_3, .x, alignment = "substructure"))

# Substituents
glycan_4 <- "Neu5Ac9Ac(a2-3)Gal(b1-4)GlcNAc(b1-"
glycan_5 <- "Neu5Ac(a2-3)Gal(b1-4)GlcNAc(b1-"

have_motif(glycan_4, glycan_5)
have_motif(glycan_5, glycan_4)
have_motif(glycan_4, glycan_4)
have_motif(glycan_5, glycan_5)

have_motif(glycan_4, glycan_5, strict_sub = FALSE)
have_motif(glycan_5, glycan_4, strict_sub = FALSE)
have_motif(glycan_4, glycan_4, strict_sub = FALSE)
have_motif(glycan_5, glycan_5, strict_sub = FALSE)

# Multiple substituents
glycan_6 <- "Glc3Me6S(a1-" # has both 3Me and 6S substituents
have_motif(glycan_6, "Glc3Me6S(a1-") # TRUE: exact match
have_motif(glycan_6, "Glc?Me6S(a1-") # TRUE: obscure linkage ?Me matches 3Me
have_motif(glycan_6, "Glc3Me?S(a1-") # TRUE: obscure linkage ?S matches 6S
have_motif(glycan_6, "Glc3Me(a1-") # FALSE: missing 6S substituent
have_motif(glycan_6, "Glc(a1-") # FALSE: missing all substituents

# Vectorization with single motif
glycans <- c(glycan, glycan_2, glycan_3)
motif <- "Gal(b1-3)GalNAc(b1-"
have_motif(glycans, motif)

# Multiple motifs with have_motifs()
glycan1 <- o_glycan_core_2(mono_type = "concrete")
glycan2 <- parse_iupac_condensed("Gal(b1-?)[GlcNAc(b1-6)]GalNAc(b1-")
glycans <- c(glycan1, glycan2)

motifs <- c("Gal(b1-3)GalNAc(b1-", "Gal(b1-4)GalNAc(b1-", "GlcNAc(b1-6)GalNAc(b1-")
have_motifs(glycans, motifs)

# You can assign each motif a name
motifs <- c(
  motif1 = "Gal(b1-3)GalNAc(b1-",
  motif2 = "Gal(b1-4)GalNAc(b1-",
  motif3 = "GlcNAc(b1-6)GalNAc(b1-"
)
have_motifs(glycans, motifs)

}
\seealso{
\code{\link[=count_motif]{count_motif()}}, \code{\link[=count_motifs]{count_motifs()}}, \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}}
}
